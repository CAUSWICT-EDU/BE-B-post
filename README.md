# 개인 노트

---
### 요구사항
- **게시글 수정 api를 추가해주세요.**
  - 기존 [PostController](./src/main/java/edu/causwict/restapi/controller/PostController.java)에 PatchMapping으로 추가
- **게시글 리스트 api를 추가해주세요.** 
  - 기존 [PostController](./src/main/java/edu/causwict/restapi/controller/PostController.java)에 GetMapping으로 추가
- **제목이 비어 있는 경우에는 게시글 작성이 되지 않게 해주세요.**
  - [PostService](./src/main/java/edu/causwict/restapi/service/PostService.java)에서 제목 검사 후 예외 throw
  - 예외 이름 정해야 함
- **제목은 30자를 넘지 않게 해주세요.**
  - 위와 같이 처리
- **중복된 제목의 게시글은 작성되지 않게 해주세요.**
  - 위와 같이 처리
- **게시글 검색 기능을 추가해주세요. (예: 제목 키워드로 검색)**
  - 위에서 만든 게시글 리스트 api를 확장하여 쓸 예정
  - @RequestParam으로 파라미터를 받아서 검색
  - 파라미터 값이 null인 경우 단순 리스트 반환으로 간주
---
***선택과제***
- **ID 생성 책임을 따로 분리하여 유틸 클래스로 만들어주세요.**
  - 아마 게시글에 붙는 ID를 말하는 것으로 추정
  - 클래스 이름 작명해야 함
- **도배 방지: 새로운 게시글 작성은 마지막 작성 이후 3분 뒤에만 가능하도록 해주세요.**
  - ID 상으로 가장 마지막 게시글이 올라온 지 3분이 지난 후 작성 가능하도록?
- **게시글을 파일로 저장/불러오기 기능을 추가해주세요.**
  - 파일 포맷 먼저 구상해야 할듯
  - 불러올 때 포맷에 안 맞으면 예외 throw
- **게시글 제목에 이모지 허용, 이모지를 1글자 취급하여 30자 제한을 유지해주세요.**
  - 👍 ← 얘가 어떻게 처리되는지를 실험해봐야 할듯
  - 일반적인 문자처럼 처리되면 상관 X
---
## 키워드 과제
### 1. SOLID 원칙이란 무엇인가요?

유지보수하기 쉽고, 테스트 하기 쉬운 코드를 만드는 원칙
1. **Single Responsibility Principle**
   - **클래스는 하나의 책임만 가져야 함**
   - *ex) 게시글 저장 기능과 알림 기능을 서로 다른 클래스로 분리*
2. **Open/Closed Principle**
   - **확장에는 열려 있고, 변경에는 닫혀 있어야 함**
   - 새로운 기능이 생기면 인터페이스를 구현하는 클래스를 생성하여 확장, 인터페이스 자체를 변경하지는 X
   - *ex) 결제 수단 별 결제 처리를 하나의 클래스에서 하지 않고 결제 수단 별로 클래스를 만들어서 인터페이스를 implements 하여 기능을 구현* 
3. **Liskov Substitution Principle**
   - **자식 클래스는 부모 클래스의 기능을 대체할 수 있어야 함**
   - 쉽게 얘기하면, 부모 클래스를 상속 받았으면 이를 제대로(예외 없이) 구현해야 함, 즉 부모의 기능을 내팽개쳐선 안됨 
   - *ex) 알림을 띄우는 기능을 가진 클래스를 상속 받은 경우 자식 클래스도 해당 기능을 수행해야 함, 예외 throw 하면 안됨*
4. **Interface Segregation Principle**
   - **인터페이스는 클라이언트가 사용하지 않는 메서드에 의존하지 않아야 함**
   - LSP 원칙을 인터페이스에 적용한 느낌
   - *ex) Car 인터페이스에는 move(), stop() 등이 있어야지, refuel() 같은게 있을 경우 이를 implements 하는 ElectricCar는 메서드를 구현할 수 없음*  
5. **Dependency Inversion Principle**
   - **고수준 모듈은 저수준 모듈에 의존하면 안되고, 추상에 의존해야 함**
   - 쉽게 얘기하면 구체적인 객체에 의존하지 말고 객체가 implements 하고 있는 인터페이스에 의존해야 함
   - *ex) DB를 다루는 인터페이스와 이를 구현한 여러 repository 클래스가 있으면 외부에서는 repository가 아닌 인터페이스에 의존*

### 2. Controller, Service, Repository, Domain 은 각각 어떤 역할을 하나요?
- **Controller** : 유저와 가장 맞닿아 있는 계층, 유저의 요청을 받아서 Service에 전달하고 그 결과를 응답으로 반환
- **Service** : 비즈니스 로직, 쉽게 말하면 데이터 처리를 담당하는 계층, Repository를 호출하여 Domain 객체를 조작
- **Repository** : DB를 직접 다루는 계층, JPA, JDBC 등으로 DB와 연결하여 CRUD 작업을 수행, Domain 객체를 저장하거나 조회
- **Domain** : 비즈니스 개념을 포함하는 객체, DB와 매핑되는 Entity도 여기에 해당, 비즈니스 로직을 수행하는 내내 Service와 Repository에서 다루는 객체

### 3. RESTful 하다는 건 결국 어떤 의미인가요 ?
- **REST** 원칙을 따른다는 의미
  - **REST**(Representational State Transfer) : 웹의 기본 원칙을 따르는 아키텍쳐 스타일로, 아래의 요소를 포함함
    1. **자원** : URI(Uniform Resource Identifier)로 표현되는 대상 (/posts, /members)
    2. **표현** : 자원의 상태를 표현하는 방식 (JSON, XML)
    3. **행위** : HTTP Method로 자원 조작 (GET, POST, PUT, DELETE)
    4. **무상태성** : 서버는 클라이언트의 상태를 저장하지 않음
    5. **일관된 인터페이스** : URI와 메서드만으로 자원 조작이 가능해야 함
- RESTful하지 않은 설계의 예시
  - /getPost → HTTP Method에 GET이 이미 있음, 잘못된 작명
  - GET /users.json → 헤더로 원하는 포맷을 지정하면 되므로 확장자를 쓰는건 불필요함
  - 세션 기반 인증 → 로그인 정보(상태)가 서버에 저장됨, 무상태성 위반
  - 모든 요청을 POST로 처리 → HTTP Method를 제대로 활용하지 않음

### 4. HTTP 통신에서 클라이언트와 서버는 어떻게 역할이 나뉠까요 ?
- **클라이언트** : 유저의 입력을 받아 서버에 자원을 요청하고 다시 유저에게 보여줌
- **서버** : 클라이언트에서 요청이 들어오면 비즈니스 로직을 수행하여 클라이언트에 전달
- **대략적인 통신 흐름** : 유저 입력 → 클라이언트 HTTP 요청 → 서버에서 처리 → HTTP 응답 반환 → 응답을 유저에게 표시

### 5. 자바 ``record`` 은 무엇인가요 ?
- **불변(immutable) 데이터 객체**
- 모든 필드가 final로 선언된다고 보면 됨
- 불변 데이터 객체를 그냥 만들면 보일러플레이트 코드가 발생하는 문제를 해결
  - 보일러플레이트 코드: 변경되는 부분이 거의 없이 여러 곳에서 재사용 하는 코드
- 여러 메서드가 자동으로 생성됨
  - 생성자: 모든 필드를 포함
  - getter: ``.필드이름()``으로 생성
  - ``equals()``: 두 record가 같은지 확인, 필드와 record 비교
  - ``hashCode()``: 객체를 해시 값으로 변환, 내용이 같은 객체는 같은 해시 값을 가짐
  - ``toString()``: ``레코드이름[필드1, 필드2]``형식으로 반환